#include <stdio.h>
int a[100001] = {1,1};
int b[100001] = {0};
int k  =0;
int main(){
   for(int i = 2;i<=10000;i++){
   	if(a[i]==0) b[++k] = i;
   	  for(int j = 1;j<=k;j++){
		 	if(i*b[j]>10000) break;
		 	a[i*b[j]] = 1;
		   if(i%b[j]==0) break;//任何一个数n = i*最小质因数
		   //如果说i%b[j]==0的话，代表i里面一定存在有以b[j]的质因数
		   //比如说。2*6=12后还没有break,而继续用3*6=18,但18还会被2*9筛选一次，所以要break;
		   //根本原因就是6中含有质因数2，3*6应该被2筛掉，而不是3
		   //至于为什么i%b[j]==0就可以判断出来，这是因为，任何一个数都会被分解成质因数的乘积
		   //6 = 2*3,如果说i%b[j]=0,即i = k*b[j]说明i里面还有一个质因数b[j],当如果继续运算用b[j+1]筛选数字时，你会发现当i =k*b[j+1]时，素数找到了b[j]
		   //与前面情况有重复，所以说，如果找到了i%b[j]==0，立马跳出循环 
		   /*对于 i%prime[j] == 0 就break的解释 ：prime= b
		   当 i是prime[j]的倍数时，i = kprime[j]，
		   如果继续运算 j+1，i * prime[j+1] = kprime[j]* prime[j+1] = 同一个合数，
		   这里prime[j]是最小的素因子，当i = k * prime[j+1]时会重复，所以才跳出循环。之后当i=k * prime[j+1]时用prime[j]删掉*/
		   //反正就是尽量保证p最小i最大 = 合数 
		   
		 }
   }	
}
